#!/usr/bin/env python
# -*- coding: utf-8 -*-

import pygame
import sys
from gui_modules.gui_base import GUI基础类
from typing import Dict, Optional, Any, List

class GUI管理器(GUI基础类):
    """GUI管理器类，负责管理不同界面并处理界面切换"""
    
    def __init__(self, 屏幕宽度=800, 屏幕高度=600, 标题="九零后时光机"):
        """初始化GUI管理器
        
        参数:
            屏幕宽度(int): 屏幕宽度
            屏幕高度(int): 屏幕高度
            标题(str): 游戏标题
        """
        # 调用父类初始化
        super().__init__(屏幕宽度, 屏幕高度, 标题)
        
        # 界面字典
        self.界面字典 = {}
        
        # 当前活动界面
        self.当前界面 = None
        
        # 界面历史记录（用于返回上一个界面）
        self.界面历史 = []
        
        # 界面切换动画状态
        self.切换动画 = {
            "进行中": False,
            "开始时间": 0,
            "持续时间": 0.5,  # 秒
            "源界面": None,
            "目标界面": None,
            "类型": "淡入淡出"  # 淡入淡出, 滑动, 缩放
        }
        
        self.界面注册表: Dict[str, Any] = {}  # 存储所有已注册的界面
        self.界面栈: List[Any] = []  # 界面栈，用于返回上一界面
        self.正在运行 = True
        
    def 注册界面(self, 界面实例):
        """注册一个界面到管理器
        
        参数:
            界面实例: 实现了GUI界面接口的实例
        """
        界面实例.设置管理器(self)
        界面名称 = 界面实例.名称
        self.界面注册表[界面名称] = 界面实例
        
    def 切换到界面(self, 界面名称: str, 参数: Any = None, 保存当前界面: bool = True):
        """切换到指定名称的界面
        
        参数:
            界面名称: 要切换到的界面名称
            参数: 传递给新界面的参数
            保存当前界面: 是否将当前界面保存到栈中
        
        返回:
            切换是否成功
        """
        if 界面名称 not in self.界面注册表:
            print(f"错误: 界面'{界面名称}'未注册")
            return False
            
        # 关闭当前界面
        if self.当前界面:
            if 保存当前界面:
                self.界面栈.append(self.当前界面)
            self.当前界面.关闭()
            
        # 切换到新界面
        self.当前界面 = self.界面注册表[界面名称]
        
        # 如果界面未初始化，先初始化
        if not self.当前界面.已初始化:
            self.当前界面.初始化()
            
        # 准备界面
        self.当前界面.准备(参数)
        return True
        
    def 返回上一界面(self, 参数: Any = None):
        """返回上一个界面
        
        参数:
            参数: 传递给前一界面的参数
            
        返回:
            返回是否成功
        """
        if not self.界面栈:
            print("错误: 界面栈为空，无法返回")
            return False
            
        # 关闭当前界面
        if self.当前界面:
            self.当前界面.关闭()
            
        # 切换到栈中最上层的界面
        self.当前界面 = self.界面栈.pop()
        
        # 准备界面
        self.当前界面.准备(参数)
        return True
        
    def 运行(self):
        """运行GUI管理器主循环"""
        while self.正在运行:
            # 处理事件
            self._处理事件()
            
            # 更新当前界面
            self._更新界面()
            
            # 控制帧率
            self.时钟.tick(60)
    
    def _处理事件(self):
        """处理所有输入事件"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            # 如果有切换动画正在进行，不处理其他事件
            if self.切换动画["进行中"]:
                continue
                
            # 将事件传递给当前界面
            if self.当前界面:
                当前界面实例 = self.界面字典[self.当前界面]
                当前界面实例.处理事件(event)
                
    def _更新界面(self):
        """更新并绘制当前界面"""
        # 如果正在进行界面切换动画
        if self.切换动画["进行中"]:
            self._处理界面切换动画()
            return
            
        # 正常更新当前界面
        if self.当前界面:
            当前界面实例 = self.界面字典[self.当前界面]
            
            # 清空按钮列表（因为每个界面有自己的按钮）
            self.按钮列表 = []
            
            # 更新并绘制界面
            当前界面实例.更新()
            
            # 进行屏幕更新
            self.更新()
            
    def _处理界面切换动画(self):
        """处理界面切换动画"""
        当前时间 = pygame.time.get_ticks()
        动画开始时间 = self.切换动画["开始时间"]
        动画持续时间 = self.切换动画["持续时间"]
        动画类型 = self.切换动画["类型"]
        源界面名称 = self.切换动画["源界面"]
        目标界面名称 = self.切换动画["目标界面"]
        
        # 计算动画进度 (0.0 到 1.0)
        进度 = min(1.0, (当前时间 - 动画开始时间) / 动画持续时间)
        
        # 获取源界面和目标界面实例
        源界面 = None if 源界面名称 is None else self.界面字典[源界面名称]
        目标界面 = self.界面字典[目标界面名称]
        
        # 根据动画类型执行不同的切换效果
        if 动画类型 == "淡入淡出":
            self._淡入淡出切换(源界面, 目标界面, 进度)
        elif 动画类型 == "滑动":
            self._滑动切换(源界面, 目标界面, 进度)
        elif 动画类型 == "缩放":
            self._缩放切换(源界面, 目标界面, 进度)
        
        # 更新屏幕
        pygame.display.flip()
        
        # 动画完成
        if 进度 >= 1.0:
            self.切换动画["进行中"] = False
            # 通知目标界面已经完成切换
            目标界面.切换完成()
    
    def _淡入淡出切换(self, 源界面, 目标界面, 进度):
        """执行淡入淡出切换动画
        
        参数:
            源界面: 源界面实例
            目标界面: 目标界面实例
            进度(float): 动画进度 (0.0 到 1.0)
        """
        # 清除屏幕
        self.清屏()
        
        # 如果有源界面，先绘制源界面
        if 源界面:
            源表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
            # 首先清空按钮列表
            旧按钮列表 = self.按钮列表.copy()
            self.按钮列表 = []
            # 更新源界面到表面
            源界面.绘制到表面(源表面)
            # 恢复按钮列表
            self.按钮列表 = 旧按钮列表
            
            # 设置源表面的透明度
            源透明度 = int(255 * (1 - 进度))
            源表面.set_alpha(源透明度)
            self.主缓冲区.blit(源表面, (0, 0))
        
        # 绘制目标界面
        目标表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
        # 首先清空按钮列表
        旧按钮列表 = self.按钮列表.copy()
        self.按钮列表 = []
        # 更新目标界面到表面
        目标界面.绘制到表面(目标表面)
        # 恢复按钮列表
        self.按钮列表 = 旧按钮列表
        
        # 设置目标表面的透明度
        目标透明度 = int(255 * 进度)
        目标表面.set_alpha(目标透明度)
        self.主缓冲区.blit(目标表面, (0, 0))
        
        # 更新整个屏幕
        self.屏幕.blit(self.主缓冲区, (0, 0))
        
    def _滑动切换(self, 源界面, 目标界面, 进度):
        """执行滑动切换动画
        
        参数:
            源界面: 源界面实例
            目标界面: 目标界面实例
            进度(float): 动画进度 (0.0 到 1.0)
        """
        # 清除屏幕
        self.清屏()
        
        # 计算偏移量
        偏移量 = int(self.屏幕宽度 * (1 - 进度))
        
        # 如果有源界面，先绘制源界面
        if 源界面:
            源表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
            # 首先清空按钮列表
            旧按钮列表 = self.按钮列表.copy()
            self.按钮列表 = []
            # 更新源界面到表面
            源界面.绘制到表面(源表面)
            # 恢复按钮列表
            self.按钮列表 = 旧按钮列表
            
            # 绘制源表面（向左滑出）
            self.主缓冲区.blit(源表面, (-偏移量, 0))
        
        # 绘制目标界面
        目标表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
        # 首先清空按钮列表
        旧按钮列表 = self.按钮列表.copy()
        self.按钮列表 = []
        # 更新目标界面到表面
        目标界面.绘制到表面(目标表面)
        # 恢复按钮列表
        self.按钮列表 = 旧按钮列表
        
        # 绘制目标表面（从右侧滑入）
        self.主缓冲区.blit(目标表面, (self.屏幕宽度 - 偏移量, 0))
        
        # 更新整个屏幕
        self.屏幕.blit(self.主缓冲区, (0, 0))
        
    def _缩放切换(self, 源界面, 目标界面, 进度):
        """执行缩放切换动画
        
        参数:
            源界面: 源界面实例
            目标界面: 目标界面实例
            进度(float): 动画进度 (0.0 到 1.0)
        """
        # 清除屏幕
        self.清屏()
        
        # 如果有源界面，先绘制源界面
        if 源界面 and 进度 < 0.5:
            源表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
            # 首先清空按钮列表
            旧按钮列表 = self.按钮列表.copy()
            self.按钮列表 = []
            # 更新源界面到表面
            源界面.绘制到表面(源表面)
            # 恢复按钮列表
            self.按钮列表 = 旧按钮列表
            
            # 计算缩放比例 (1.0 -> 0.8)
            缩放比例 = 1.0 - (进度 * 0.4)
            缩放宽度 = int(self.屏幕宽度 * 缩放比例)
            缩放高度 = int(self.屏幕高度 * 缩放比例)
            
            # 缩放源表面
            缩放表面 = pygame.transform.smoothscale(源表面, (缩放宽度, 缩放高度))
            
            # 计算中心位置
            x = (self.屏幕宽度 - 缩放宽度) // 2
            y = (self.屏幕高度 - 缩放高度) // 2
            
            # 绘制缩放后的表面
            self.主缓冲区.blit(缩放表面, (x, y))
            
        # 绘制目标界面
        if 进度 >= 0.5:
            目标表面 = pygame.Surface((self.屏幕宽度, self.屏幕高度))
            # 首先清空按钮列表
            旧按钮列表 = self.按钮列表.copy()
            self.按钮列表 = []
            # 更新目标界面到表面
            目标界面.绘制到表面(目标表面)
            # 恢复按钮列表
            self.按钮列表 = 旧按钮列表
            
            # 计算缩放比例 (0.8 -> 1.0)
            缩放比例 = 0.8 + ((进度 - 0.5) * 0.4 * 2)
            缩放宽度 = int(self.屏幕宽度 * 缩放比例)
            缩放高度 = int(self.屏幕高度 * 缩放比例)
            
            # 缩放目标表面
            缩放表面 = pygame.transform.smoothscale(目标表面, (缩放宽度, 缩放高度))
            
            # 计算中心位置
            x = (self.屏幕宽度 - 缩放宽度) // 2
            y = (self.屏幕高度 - 缩放高度) // 2
            
            # 绘制缩放后的表面
            self.主缓冲区.blit(缩放表面, (x, y))
            
        # 更新整个屏幕
        self.屏幕.blit(self.主缓冲区, (0, 0))

    def 显示消息(self, 消息, 持续时间=3):
        """显示一条临时消息
        
        参数:
            消息(str): 要显示的消息
            持续时间(float): 显示时间（秒）
        """
        self.显示文本(消息)
        self.消息计时器 = pygame.time.get_ticks()
        # 持续时间转为毫秒存储
        self.消息持续时间 = 持续时间 * 1000 

    def 退出(self):
        """退出界面管理器"""
        self.正在运行 = False
        
        # 关闭所有界面
        if self.当前界面:
            self.当前界面.关闭()
            
        for 界面 in self.界面栈:
            界面.关闭()
            
        self.界面栈.clear()
        self.当前界面 = None 